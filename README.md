Data Engineer Take-Home Assessment
Overview
This project demonstrates my skills in building an end-to-end data pipeline, from data collection to storage, and finally to data retrieval through a custom API. The project involves working with the NIST NVD CVE API, storing the collected data in a MySQL database, and designing a REST API to query and analyze the stored data.

Table of Contents
Overview
Setup Instructions
Prerequisites
Data Collection Script
Database Setup
API Development
Database Schema
API Documentation
Endpoints
Analytical Questions
Evaluation Criteria
Conclusion
Setup Instructions
Prerequisites
Ensure you have the following installed:

Python 3.8+
MySQL
Git
Install required Python packages:

sh
Копировать код
pip install requests pymysql flask flask-mysqldb
Data Collection Script
Clone the repository:

sh
Копировать код
git clone <repository_url>
cd <repository_name>
Run the data collection script:

sh
Копировать код
python data_collection.py
This script fetches CVE data from the NIST NVD API and saves it in a JSON file (cve_data.json).

Database Setup
Start your MySQL server and create a database:

sql
Копировать код
CREATE DATABASE cve_data;
Run the database schema script to create tables:

sh
Копировать код
python create_schema.py
Load the collected data into the database:

sh
Копировать код
python load_data.py
API Development
Start the Flask API server:
sh
Копировать код
python app.py
The API will be accessible at http://127.0.0.1:5000/.
Database Schema
The database schema consists of several tables to efficiently store CVE data with appropriate normalization and indexing:

sql
Копировать код
CREATE TABLE CVE (
    CVE_ID VARCHAR(15) PRIMARY KEY,
    Description TEXT,
    Published_Date DATETIME,
    Last_Modified_Date DATETIME,
    Severity VARCHAR(50)
);

CREATE TABLE Product (
    Product_ID INT AUTO_INCREMENT PRIMARY KEY,
    Name VARCHAR(100) NOT NULL
);

CREATE TABLE Platform (
    Platform_ID INT AUTO_INCREMENT PRIMARY KEY,
    Name VARCHAR(100) NOT NULL
);

CREATE TABLE CVSSMetrics (
    CVE_ID VARCHAR(15),
    Version VARCHAR(5),
    VectorString VARCHAR(255),
    AccessVector VARCHAR(50),
    AccessComplexity VARCHAR(50),
    Authentication VARCHAR(50),
    ConfidentialityImpact VARCHAR(50),
    IntegrityImpact VARCHAR(50),
    AvailabilityImpact VARCHAR(50),
    BaseScore DECIMAL(3,1),
    ExploitabilityScore DECIMAL(3,1),
    ImpactScore DECIMAL(3,1),
    AttackVector VARCHAR(50),
    PRIMARY KEY (CVE_ID, Version),
    FOREIGN KEY (CVE_ID) REFERENCES CVE(CVE_ID)
);

CREATE TABLE Vulnerability_Product (
    CVE_ID VARCHAR(15),
    Product_ID INT,
    PRIMARY KEY (CVE_ID, Product_ID),
    FOREIGN KEY (CVE_ID) REFERENCES CVE(CVE_ID),
    FOREIGN KEY (Product_ID) REFERENCES Product(Product_ID)
);

CREATE TABLE Vulnerability_Platform (
    CVE_ID VARCHAR(15),
    Platform_ID INT,
    PRIMARY KEY (CVE_ID, Platform_ID),
    FOREIGN KEY (CVE_ID) REFERENCES CVE(CVE_ID),
    FOREIGN KEY (Platform_ID) REFERENCES Platform(Platform_ID)
);
API Documentation
Endpoints
Get CVE by ID
URL: /cve/<cve_id>
Method: GET
URL Params: cve_id=[string] - The ID of the CVE.
Success Response:
Code: 200
Content: { "CVE_ID": "CVE-1999-0211", "Description": "...", ... }
Error Response:
Code: 404
Content: { "error": "CVE not found" }
Get CVEs by Severity
URL: /cve/severity/<severity>
Method: GET
URL Params: severity=[string] - The severity level (e.g., "HIGH", "MEDIUM", "LOW").
Success Response:
Code: 200
Content: [ { "Severity": "HIGH", "Count": 123 }, ... ]
Get Top 10 Vulnerabilities by Impact Score
URL: /cve/top-impact
Method: GET
Success Response:
Code: 200
Content: [ { "CVE_ID": "CVE-1999-0211", "ImpactScore": 10.0 }, ... ]
Get Top 10 Vulnerabilities by Exploitability Score
URL: /cve/top-exploitability
Method: GET
Success Response:
Code: 200
Content: [ { "CVE_ID": "CVE-1999-0211", "ExploitabilityScore": 10.0 }, ... ]
Get Worst Products
URL: /cve/worst-products
Method: GET
Success Response:
Code: 200
Content: [ { "Name": "Product A", "Count": 123 }, ... ]
Get Worst Platforms
URL: /cve/worst-platforms
Method: GET
Success Response:
Code: 200
Content: [ { "Name": "Platform A", "Count": 123 }, ... ]
Analytical Questions
The API includes endpoints to answer the following analytical questions:

Severity Distribution: Count of vulnerabilities for different severity levels.
Worst Products/Platforms: Products and platforms with the most known vulnerabilities.
Top 10 Vulnerabilities by Impact: Vulnerabilities with the highest impact.
Top 10 Vulnerabilities by Exploitability: Vulnerabilities with the highest exploitability scores.
Top 10 Attack Vectors: Most common attack vectors used in vulnerabilities.
Evaluation Criteria
Code Quality: Clarity, readability, and maintainability of code.
Database Design: Efficiency and appropriateness of the database schema.
API Functionality: Completeness, reliability, and performance of the API.
Problem Solving: Ability to answer analytical questions through API design.
Documentation: Clarity and completeness of the README and API documentation.
Conclusion
This project showcases the complete pipeline from data collection and storage to data analysis and API development. The structure and clarity of the code, the efficiency of the database design, and the functionality of the API are designed to meet the specified evaluation criteria.